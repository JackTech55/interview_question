# Technical Interview Answers
## Sameer Soumya Ranjan Jena - Full Stack Developer

---

## 1. Tell me something about yourself

Hello! I'm Sameer Soumya Ranjan Jena, a passionate Full Stack Developer with 6.5 years of comprehensive experience in crafting robust web applications. My journey began as a Junior Developer at Resource Technology in 2017, and I've evolved into a skilled professional currently working at ZKTeco Biometric Pvt. Ltd. in Bangalore.

What drives me is the belief that software development is the cornerstone of organizational growth and success. I specialize in PHP and Laravel for backend development, complemented by React and Vue.js for creating intuitive user interfaces. My expertise spans the entire development lifecycle, from analyzing functional specifications to deploying scalable applications on AWS infrastructure.

I'm not just a coder; I'm a problem solver who thrives in collaborative environments. Whether it's optimizing database queries, implementing secure APIs, or mentoring team members, I bring both technical excellence and leadership qualities to every project. My adaptability allows me to quickly master new technologies while maintaining focus on delivering high-quality, user-centric solutions.

---

## 2. Which type of projects have you done? Explain

Throughout my career, I've had the privilege of working on diverse, impactful projects across multiple industries:

**Current Project - ZKDigimax (Aug 2023 - Present):**
I'm developing a comprehensive marketing and sales platform for ZKTeco's AI-powered biometric products. This project showcases my full-stack capabilities using Laravel, Vue.js, and Vuetify, featuring dynamic product categorization, multilingual support, and advanced analytics integration with Google Analytics.

**Mobtexting Platform (Sept 2022 - Aug 2023):**
Led development of a multi-channel communication platform supporting SMS, Voice, WhatsApp, and RCS messaging. This enterprise-level application serves thousands of users running cost-effective advertising campaigns, demonstrating my ability to handle high-volume, real-time messaging systems.

**Healthcare - MLC & Leixir Digital (Oct 2021 - Sept 2022):**
Developed a sophisticated dental clinic management system connecting labs, design centers, and doctors across USA and India. The platform features real-time case tracking, automated scheduling, and comprehensive reporting with visual analytics through charts and graphs.

**HRMS System (July 2020):**
Built a complete Human Resource Management System handling payroll processing, recruitment workflows, performance evaluations, and employee self-service portals. This project showcased my ability to create complex business applications with intricate data relationships.

**E-commerce Platform - Richkaart (Sept 2019):**
Architected a full-featured e-commerce solution supporting vendor management, advanced product filtering, shopping cart functionality, and secure payment processing. This project demonstrated my understanding of scalable commerce architectures.

**Healthcare Insurance System (Jan 2018):**
Contributed to a large-scale government eligibility system supporting SNAP, CCAP, Medicare, and other social programs. Working with a 30-member team, I learned the importance of robust system architecture and compliance in critical healthcare applications.

---

## 3. What are Magic Methods in PHP?

Magic methods in PHP are special predefined methods that begin with double underscores (`__`) and are automatically invoked by PHP when certain operations are performed on objects. They provide a powerful way to implement dynamic behavior and object interaction.

**Key Magic Methods:**

```php
class User {
    private $data = [];
    
    // __construct - Called when object is created
    public function __construct($name, $email) {
        $this->data['name'] = $name;
        $this->data['email'] = $email;
    }
    
    // __get - Called when accessing inaccessible properties
    public function __get($property) {
        return isset($this->data[$property]) ? $this->data[$property] : null;
    }
    
    // __set - Called when setting inaccessible properties
    public function __set($property, $value) {
        $this->data[$property] = $value;
    }
    
    // __toString - Called when object is treated as string
    public function __toString() {
        return $this->data['name'];
    }
    
    // __call - Called when invoking inaccessible methods
    public function __call($method, $arguments) {
        if (strpos($method, 'get') === 0) {
            $property = lcfirst(substr($method, 3));
            return $this->__get($property);
        }
    }
}
```

These magic methods enable elegant object-oriented design patterns and are extensively used in frameworks like Laravel for implementing models, collections, and facades.

---

## 4. Explain the array function in PHP

PHP offers an extensive collection of array functions that make data manipulation efficient and elegant. Here are the essential ones I frequently use in my projects:

**Array Creation and Manipulation:**
```php
// Creating arrays
$fruits = array('apple', 'banana', 'orange');
$colors = ['red', 'green', 'blue'];

// Adding elements
array_push($fruits, 'mango');
array_unshift($fruits, 'grape'); // Add to beginning

// Removing elements
$lastFruit = array_pop($fruits);
$firstFruit = array_shift($fruits);
```

**Searching and Filtering:**
```php
// Searching
$key = array_search('banana', $fruits);
$exists = in_array('apple', $fruits);

// Filtering
$numbers = [1, 2, 3, 4, 5, 6];
$evenNumbers = array_filter($numbers, function($n) {
    return $n % 2 == 0;
});

// Mapping
$squared = array_map(function($n) {
    return $n * $n;
}, $numbers);
```

**Array Information and Sorting:**
```php
// Information
$count = count($fruits);
$keys = array_keys($associativeArray);
$values = array_values($associativeArray);

// Sorting
sort($fruits); // Ascending
rsort($fruits); // Descending
asort($associativeArray); // Sort by values, maintain keys
ksort($associativeArray); // Sort by keys
```

**Advanced Operations:**
```php
// Merging and combining
$combined = array_merge($array1, $array2);
$flipped = array_flip($array); // Swap keys and values

// Reducing
$sum = array_reduce($numbers, function($carry, $item) {
    return $carry + $item;
}, 0);
```

---

## 5. What is the @CSRF token in Laravel, and how does it work?

CSRF (Cross-Site Request Forgery) protection is a critical security feature in Laravel that prevents unauthorized commands from being transmitted from users that the application trusts.

**How CSRF Works:**

When a user visits a Laravel application, the framework generates a unique, unpredictable token for that user's session. This token must be included with every state-changing HTTP request (POST, PUT, DELETE) to verify the request's authenticity.

**Implementation:**

```php
// In Blade templates
<form method="POST" action="/user/profile">
    @csrf
    <input type="text" name="name" value="John">
    <button type="submit">Update Profile</button>
</form>

// This generates:
<input type="hidden" name="_token" value="randomly_generated_token_here">
```

**JavaScript/AJAX Implementation:**
```javascript
// Getting CSRF token for AJAX requests
let token = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': token
    }
});

// Or in individual requests
$.post('/api/users', {
    _token: token,
    name: 'John Doe'
});
```

**Middleware Protection:**
Laravel's `VerifyCsrfToken` middleware automatically validates CSRF tokens for all POST, PUT, PATCH, and DELETE requests. If the token is missing or invalid, Laravel returns a 419 status code.

**Token Management:**
```php
// Generating new token
$token = csrf_token();

// In controllers, you can exclude specific routes
protected $except = [
    'webhook/payment/*',
    'api/external/*'
];
```

This protection ensures that only forms generated by your application can submit data, preventing malicious websites from performing unauthorized actions on behalf of authenticated users.

---

## 6. How to find duplicate salaries in the Employees table

Finding duplicate salaries is a common database challenge that can be solved elegantly using SQL aggregation and grouping:

**Method 1 - Using GROUP BY and HAVING:**
```sql
-- Find all duplicate salaries with their counts
SELECT salary, COUNT(*) as duplicate_count
FROM employees 
GROUP BY salary 
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC;

-- Find employees with duplicate salaries
SELECT e1.employee_id, e1.name, e1.salary 
FROM employees e1
WHERE e1.salary IN (
    SELECT salary 
    FROM employees 
    GROUP BY salary 
    HAVING COUNT(*) > 1
)
ORDER BY e1.salary, e1.name;
```

**Method 2 - Using Window Functions (More Efficient):**
```sql
-- Using ROW_NUMBER() to identify duplicates
WITH DuplicateSalaries AS (
    SELECT 
        employee_id,
        name,
        salary,
        ROW_NUMBER() OVER (PARTITION BY salary ORDER BY employee_id) as row_num,
        COUNT(*) OVER (PARTITION BY salary) as salary_count
    FROM employees
)
SELECT employee_id, name, salary, salary_count
FROM DuplicateSalaries 
WHERE salary_count > 1
ORDER BY salary, row_num;
```

**Method 3 - Self Join Approach:**
```sql
-- Using self-join to find duplicates
SELECT DISTINCT e1.employee_id, e1.name, e1.salary
FROM employees e1
INNER JOIN employees e2 ON e1.salary = e2.salary 
WHERE e1.employee_id != e2.employee_id
ORDER BY e1.salary, e1.employee_id;
```

**Laravel Eloquent Implementation:**
```php
// Using Laravel's Query Builder
$duplicateSalaries = DB::table('employees')
    ->select('salary', DB::raw('COUNT(*) as count'))
    ->groupBy('salary')
    ->having('count', '>', 1)
    ->orderBy('count', 'desc')
    ->get();

// Get employees with duplicate salaries
$employeesWithDuplicates = Employee::whereIn('salary', 
    $duplicateSalaries->pluck('salary')
)->orderBy('salary')->get();
```

---

## 7. How to find the maximum salary from the employees table

Finding maximum salary can be approached in several ways depending on your specific requirements:

**Method 1 - Simple MAX() Function:**
```sql
-- Get the highest salary value
SELECT MAX(salary) as maximum_salary 
FROM employees;

-- Get employee(s) with maximum salary
SELECT employee_id, name, salary 
FROM employees 
WHERE salary = (SELECT MAX(salary) FROM employees);
```

**Method 2 - Using ORDER BY and LIMIT:**
```sql
-- Get top earner(s)
SELECT employee_id, name, salary 
FROM employees 
ORDER BY salary DESC 
LIMIT 1;

-- Get top 5 highest salaries
SELECT employee_id, name, salary 
FROM employees 
ORDER BY salary DESC 
LIMIT 5;
```

**Method 3 - Department-wise Maximum:**
```sql
-- Maximum salary by department
SELECT 
    department,
    MAX(salary) as max_salary,
    COUNT(*) as employees_in_dept
FROM employees 
GROUP BY department
ORDER BY max_salary DESC;

-- Employees with maximum salary in each department
SELECT e1.department, e1.name, e1.salary
FROM employees e1
WHERE e1.salary = (
    SELECT MAX(e2.salary) 
    FROM employees e2 
    WHERE e2.department = e1.department
)
ORDER BY e1.department;
```

**Method 4 - Using Window Functions:**
```sql
-- Rank employees by salary
WITH SalaryRanks AS (
    SELECT 
        employee_id,
        name,
        salary,
        department,
        RANK() OVER (ORDER BY salary DESC) as salary_rank,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
    FROM employees
)
SELECT * FROM SalaryRanks 
WHERE salary_rank = 1; -- Overall highest
```

**Laravel Eloquent Implementation:**
```php
// Simple maximum salary
$maxSalary = Employee::max('salary');

// Employee(s) with maximum salary
$topEarners = Employee::where('salary', Employee::max('salary'))->get();

// Using collections for more complex operations
$maxSalaryByDept = Employee::all()
    ->groupBy('department')
    ->map(function($employees) {
        return $employees->max('salary');
    });

// Top N highest salaries
$topEarners = Employee::orderBy('salary', 'desc')->take(5)->get();
```

---

## 8. What is an aggregate function in SQL?

Aggregate functions are powerful SQL functions that perform calculations on multiple rows of data and return a single summarized result. They are essential for data analysis and reporting in database applications.

**Core Aggregate Functions:**

**COUNT() - Counting Records:**
```sql
-- Count all employees
SELECT COUNT(*) as total_employees FROM employees;

-- Count non-null salaries
SELECT COUNT(salary) as employees_with_salary FROM employees;

-- Count distinct departments
SELECT COUNT(DISTINCT department) as unique_departments FROM employees;
```

**SUM() - Mathematical Addition:**
```sql
-- Total payroll
SELECT SUM(salary) as total_payroll FROM employees;

-- Department-wise total salaries
SELECT department, SUM(salary) as dept_payroll 
FROM employees 
GROUP BY department;
```

**AVG() - Average Values:**
```sql
-- Average salary across company
SELECT AVG(salary) as average_salary FROM employees;

-- Average salary by experience level
SELECT experience_level, AVG(salary) as avg_salary 
FROM employees 
GROUP BY experience_level
ORDER BY avg_salary DESC;
```

**MIN() and MAX() - Extreme Values:**
```sql
-- Salary range analysis
SELECT 
    MIN(salary) as lowest_salary,
    MAX(salary) as highest_salary,
    MAX(salary) - MIN(salary) as salary_range
FROM employees;
```

**Advanced Aggregate Usage:**
```sql
-- Comprehensive department analysis
SELECT 
    department,
    COUNT(*) as employee_count,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary,
    SUM(salary) as total_payroll,
    STDDEV(salary) as salary_variance
FROM employees 
GROUP BY department
HAVING COUNT(*) > 5 -- Only departments with more than 5 employees
ORDER BY avg_salary DESC;
```

**Window Functions with Aggregates:**
```sql
-- Running totals and moving averages
SELECT 
    employee_id,
    name,
    salary,
    SUM(salary) OVER (ORDER BY employee_id) as running_total,
    AVG(salary) OVER (ORDER BY employee_id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg_3
FROM employees;
```

**Laravel Query Builder Implementation:**
```php
// Basic aggregates
$stats = DB::table('employees')->selectRaw('
    COUNT(*) as total_employees,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary,
    SUM(salary) as total_payroll
')->first();

// Grouped aggregates
$deptStats = Employee::select('department')
    ->selectRaw('COUNT(*) as count, AVG(salary) as avg_salary')
    ->groupBy('department')
    ->having('count', '>', 5)
    ->orderBy('avg_salary', 'desc')
    ->get();
```

---

## 9. Difference between implode and explode in PHP

The `implode()` and `explode()` functions are complementary string manipulation functions in PHP that I use frequently for data processing in my applications.

**EXPLODE() - String to Array:**
The `explode()` function breaks a string into an array using a specified delimiter.

```php
// Basic syntax: explode(delimiter, string, limit)

// Example 1: Processing CSV data
$csvRow = "John,Doe,30,Engineer";
$userData = explode(",", $csvRow);
// Result: ["John", "Doe", "30", "Engineer"]

// Example 2: Processing URLs
$url = "https://example.com/users/profile/edit";
$urlParts = explode("/", $url);
// Result: ["https:", "", "example.com", "users", "profile", "edit"]

// Example 3: With limit parameter
$text = "apple-banana-orange-mango";
$fruits = explode("-", $text, 3);
// Result: ["apple", "banana", "orange-mango"]

// Real-world usage in my projects
$tags = explode(",", $product->tags); // Convert stored tags to array
$emailParts = explode("@", $userEmail); // Separate username and domain
```

**IMPLODE() - Array to String:**
The `implode()` function joins array elements into a string using a specified separator.

```php
// Basic syntax: implode(separator, array) or implode(array) - uses empty string

// Example 1: Creating formatted lists
$names = ["John", "Jane", "Bob", "Alice"];
$nameList = implode(", ", $names);
// Result: "John, Jane, Bob, Alice"

// Example 2: Building SQL queries
$conditions = ["status = 'active'", "age > 18", "department = 'IT'"];
$whereClause = "WHERE " . implode(" AND ", $conditions);
// Result: "WHERE status = 'active' AND age > 18 AND department = 'IT'"

// Example 3: Creating file paths
$pathParts = ["uploads", "users", "2023", "profile_images"];
$fullPath = implode("/", $pathParts);
// Result: "uploads/users/2023/profile_images"

// Real-world usage in my Laravel projects
$selectedIds = implode(",", $request->selected_items); // For database queries
$breadcrumbs = implode(" > ", $navigationPath); // For UI breadcrumbs
```

**Practical Applications in My Projects:**

```php
// Processing form data with multiple selections
$selectedCategories = $request->input('categories'); // Array from form
$categoriesString = implode(",", $selectedCategories); // Store in database

// Later retrieving and processing
$storedCategories = $product->categories; // "1,5,8,12"
$categoryArray = explode(",", $storedCategories); // Convert back to array
$categoryNames = Category::whereIn('id', $categoryArray)->pluck('name');

// CSV file processing
$csvContent = file_get_contents('employees.csv');
$lines = explode("\n", $csvContent);
foreach ($lines as $line) {
    $employeeData = explode(",", $line);
    // Process each employee record
}

// Creating dynamic SQL queries
$searchTerms = explode(" ", $request->search_query);
$conditions = array_map(function($term) {
    return "name LIKE '%$term%'";
}, $searchTerms);
$sql = "SELECT * FROM products WHERE " . implode(" OR ", $conditions);
```

**Key Differences Summary:**
- **Direction**: `explode()` converts string → array, `implode()` converts array → string
- **Use Cases**: `explode()` for parsing/splitting data, `implode()` for formatting/joining data
- **Parameters**: `explode(delimiter, string)`, `implode(separator, array)`
- **Data Flow**: They perform inverse operations of each other

---

## 10. Caches in Laravel

Caching is a cornerstone of high-performance web applications, and Laravel provides a robust, unified caching system that I leverage extensively in my projects to optimize performance and user experience.

**Laravel Cache Drivers:**

Laravel supports multiple cache backends, allowing flexibility based on infrastructure needs:

```php
// Configuration in config/cache.php
'stores' => [
    'file' => ['driver' => 'file', 'path' => storage_path('framework/cache/data')],
    'redis' => ['driver' => 'redis', 'connection' => 'cache'],
    'memcached' => ['driver' => 'memcached', 'servers' => [...]],
    'database' => ['driver' => 'database', 'table' => 'cache'],
    'array' => ['driver' => 'array', 'serialize' => false],
]
```

**Basic Cache Operations:**

```php
use Illuminate\Support\Facades\Cache;

// Storing data
Cache::put('user_preferences_' . $userId, $preferences, 3600); // 1 hour
Cache::forever('site_settings', $settings); // Permanent until manually cleared

// Retrieving data
$preferences = Cache::get('user_preferences_' . $userId);
$settings = Cache::get('site_settings', 'default_value');

// Check existence
if (Cache::has('expensive_calculation')) {
    $result = Cache::get('expensive_calculation');
} else {
    $result = performExpensiveCalculation();
    Cache::put('expensive_calculation', $result, 1800); // 30 minutes
}

// Remove from cache
Cache::forget('user_session_' . $sessionId);
Cache::flush(); // Clear all cache
```

**Advanced Caching Patterns:**

**Remember Pattern (Cache with Callback):**
```php
// Cache expensive database queries
$popularProducts = Cache::remember('popular_products', 3600, function () {
    return Product::with('reviews')
        ->where('rating', '>', 4.5)
        ->orderBy('sales_count', 'desc')
        ->take(10)
        ->get();
});

// User-specific caching
$userDashboard = Cache::remember("dashboard_{$user->id}", 1800, function () use ($user) {
    return [
        'recent_orders' => $user->orders()->recent()->get(),
        'recommendations' => $this->getRecommendations($user),
        'analytics' => $this->getUserAnalytics($user)
    ];
});
```

**Tagged Caching:**
```php
// Group related cache entries
Cache::tags(['users', 'profiles'])->put("user_{$id}", $user, 3600);
Cache::tags(['products', 'inventory'])->put("product_{$id}", $product, 7200);

// Invalidate by tags
Cache::tags(['users'])->flush(); // Clear all user-related cache
Cache::tags(['products', 'categories'])->flush(); // Clear multiple tags
```

**Cache in Real-World Applications:**

**API Response Caching:**
```php
public function getProductCatalog(Request $request) {
    $cacheKey = 'catalog_' . md5($request->getQueryString());
    
    return Cache::remember($cacheKey, 1800, function () use ($request) {
        return Product::with(['category', 'images'])
            ->filter($request->all())
            ->paginate(20);
    });
}
```

**Database Query Optimization:**
```php
// Model-level caching
class Product extends Model {
    public function getCachedReviews() {
        return Cache::remember("product_reviews_{$this->id}", 3600, function () {
            return $this->reviews()
                ->with('user')
                ->approved()
                ->latest()
                ->get();
        });
    }
}

// Relationship caching
public function categories() {
    return Cache::remember('all_categories', 7200, function () {
        return Category::with('children')
            ->whereNull('parent_id')
            ->orderBy('sort_order')
            ->get();
    });
}
```

**Session and User State Caching:**
```php
// Cache user permissions
$permissions = Cache::remember("user_permissions_{$user->id}", 3600, function () use ($user) {
    return $user->roles()
        ->with('permissions')
        ->get()
        ->pluck('permissions')
        ->flatten()
        ->pluck('name')
        ->unique()
        ->values();
});

// Shopping cart caching
Cache::put("cart_{$sessionId}", $cartItems, 2592000); // 30 days
```

**Performance Monitoring and Cache Optimization:**
```php
// Cache hit/miss tracking
public function getCachedData($key, $callback, $ttl = 3600) {
    if (Cache::has($key)) {
        Log::info("Cache HIT: {$key}");
        return Cache::get($key);
    }
    
    Log::info("Cache MISS: {$key}");
    $data = $callback();
    Cache::put($key, $data, $ttl);
    return $data;
}
```

**Cache Implementation Best Practices I Follow:**
- Use descriptive, hierarchical cache keys with appropriate prefixes
- Implement cache warming strategies for critical data
- Set appropriate TTL values based on data volatility
- Use cache tags for efficient invalidation
- Monitor cache hit ratios and optimize accordingly
- Implement fallback mechanisms for cache failures
- Use Redis for session storage and high-frequency cache operations

---

## 11. Difference between hashing and encrypting in Laravel

Understanding the distinction between hashing and encryption is crucial for implementing proper security measures. Both serve different purposes in Laravel applications.

**HASHING - One-Way Transformation:**

Hashing is a one-way cryptographic function that transforms data into a fixed-length string. It's irreversible by design and primarily used for data integrity and password security.

```php
use Illuminate\Support\Facades\Hash;

// Creating hashes (typically for passwords)
$hashedPassword = Hash::make('user_password123');
// Result: $2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi

// Verifying hashes
if (Hash::check('user_password123', $hashedPassword)) {
    // Password is correct
    return "Authentication successful";
}

// Different input = completely different hash
$hash1 = Hash::make('password123');
$hash2 = Hash::make('password123');
// $hash1 !== $hash2 (due to salt), but both verify correctly
```

**Real-world Hashing Applications in My Projects:**
```php
// User registration
public function register(Request $request) {
    User::create([
        'name' => $request->name,
        'email' => $request->email,
        'password' => Hash::make($request->password), // Hashed, never reversed
    ]);
}

// API token generation
$apiToken = Hash::make($user->id . time() . Str::random(40));

// File integrity checking
$fileHash = hash_file('sha256', $uploadedFile->getPathname());
Storage::put('file_checksums.txt', $fileHash);
```

**ENCRYPTION - Two-Way Transformation:**

Encryption is a reversible process that transforms data into an unreadable format using a key, allowing decryption back to original data when needed.

```php
use Illuminate\Support\Facades\Crypt;

// Encrypting sensitive data
$encryptedData = Crypt::encrypt('sensitive_user_data');
// Result: eyJpdiI6IlBQUFNuOG5USkl6UlBHcVwvQStcL0E9PSIsInZhbHVlIjoic...

// Decrypting data
$originalData = Crypt::decrypt($encryptedData);
// Result: 'sensitive_user_data'

// Encrypting arrays/objects
$userData = [
    'ssn' => '123-45-6789',
    'credit_card' => '1234-5678-9012-3456'
];
$encryptedUserData = Crypt::encrypt($userData);
$decryptedUserData = Crypt::decrypt($encryptedUserData);
```

**Advanced Encryption Usage:**
```php
// Custom encryption for specific use cases
use Illuminate\Encryption\Encrypter;

$customKey = base64_decode(config('app.custom_encryption_key'));
$encrypter = new Encrypter($customKey, 'AES-256-CBC');

$encrypted = $encrypter->encrypt($sensitiveData);
$decrypted = $encrypter->decrypt($encrypted);

// Database field encryption
class User extends Model {
    protected $casts = [
        'social_security' => 'encrypted',
        'bank_details' => 'encrypted:array',
    ];
}
```

**Practical Implementation Examples:**

**Password Management System:**
```php
class AuthService {
    // Hash passwords (one-way)
    public function hashPassword($password) {
        return Hash::make($password);
    }
    
    // Verify passwords
    public function verifyPassword($password, $hashedPassword) {
        return Hash::check($password, $hashedPassword);
    }
    
    // Encrypt sensitive user data (reversible)
    public function encryptSensitiveData($data) {
        return Crypt::encrypt($data);
    }
    
    // Decrypt when needed
    public function decryptSensitiveData($encryptedData) {
        return Crypt::decrypt($encryptedData);
    }
}
```

**E-commerce Payment Processing:**
```php
// Store encrypted payment information
public function storePaymentMethod(Request $request) {
    PaymentMethod::create([
        'user_id' => auth()->id(),
        'card_number' => Crypt::encrypt($request->card_number),
        'expiry_date' => Crypt::encrypt($request->expiry_date),
        'card_hash' => Hash::make($request->card_number), // For identification
    ]);
}

// Retrieve and use payment information
public function processPayment($paymentMethodId) {
    $paymentMethod = PaymentMethod::find($paymentMethodId);
    
    $cardNumber = Crypt::decrypt($paymentMethod->card_number);
    $expiryDate = Crypt::decrypt($paymentMethod->expiry_date);
    
    // Process payment with decrypted data
}
```

**Key Differences Summary:**

| Aspect | Hashing | Encryption |
|--------|---------|------------|
| **Reversibility** | One-way (irreversible) | Two-way (reversible) |
| **Primary Use** | Password storage, data integrity | Sensitive data protection |
| **Key Required** | No (salt used) | Yes (encryption key) |
| **Output Consistency** | Different each time (salted) | Consistent for same input/key |
| **Security Purpose** | Authentication, integrity | Confidentiality |
| **Laravel Methods** | `Hash::make()`, `Hash::check()` | `Crypt::encrypt()`, `Crypt::decrypt()` |
| **Common Use Cases** | Passwords, API tokens, checksums | PII, payment data, private messages |
| **Performance** | Generally faster | Slower due to key operations |

**Security Best Practices I Follow:**
- Hash all passwords and never store them in plain text
- Encrypt sensitive data like SSNs, payment information, private messages
- Use Laravel's built-in encryption for consistency and security
- Rotate encryption keys periodically
- Never hash data that needs to be retrieved in original form
- Use appropriate hashing algorithms (bcrypt, argon2) for passwords
- Implement proper key management for encrypted data

---

## 12. Array Rotation Problem: Input = [1,2,3,4,5,6,7]; Output = [7,1,2,3,4,5,6]

This is a classic array manipulation problem that demonstrates right rotation by one position. Let me provide multiple elegant solutions:

**Solution 1 - PHP Built-in Functions (Most Readable):**
```php
function rotateArrayRight($arr, $positions = 1) {
    $length = count($arr);
    if ($length === 0) return $arr;
    
    // Normalize positions to avoid unnecessary rotations
    $positions = $positions % $length;
    
    // Extract elements to move to front
    $elementsToMove = array_slice($arr, -$positions);
    // Get remaining elements
    $remainingElements = array_slice($arr, 0, -$positions);
    
    // Combine arrays
    return array_merge($elementsToMove, $remainingElements);
}

// Usage
$input = [1, 2, 3, 4, 5, 6, 7];
$output = rotateArrayRight($input, 1);
// Result: [7, 1, 2, 3, 4, 5, 6]

// Multiple rotations
$output2 = rotateArrayRight($input, 3);
// Result: [5, 6, 7, 1, 2, 3, 4]
```

**Solution 2 - Manual Implementation (Optimal Performance):**
```php
function rotateArrayManual($arr, $positions = 1) {
    $length = count($arr);
    if ($length === 0) return $arr;
    
    $positions = $positions % $length;
    $result = [];
    
    // Add elements from the end
    for ($i = $length - $positions; $i < $length; $i++) {
        $result[] = $arr[$i];
    }
    
    // Add remaining elements from the beginning
    for ($i = 0; $i < $length - $positions; $i++) {
        $result[] = $arr[$i];
    }
    
    return $result;
}
```

**Solution 3 - In-Place Rotation (Memory Efficient):**
```php
function rotateArrayInPlace(&$arr, $positions = 1) {
    $length = count($arr);
    if ($length === 0) return;
    
    $positions = $positions % $length;
    
    // Reverse entire array
    $arr = array_reverse($arr);
    
    // Reverse first 'positions' elements
    $firstPart = array_reverse(array_slice($arr, 0, $positions));
    
    // Reverse remaining elements
    $secondPart = array_reverse(array_slice($arr, $positions));
    
    // Combine
    $arr = array_merge($firstPart, $secondPart);
}

// Usage
$input = [1, 2, 3, 4, 5, 6, 7];
rotateArrayInPlace($input, 1);
// $input is now [7, 1, 2, 3, 4, 5, 6]
```

**Solution 4 - Functional Approach with Array Functions:**
```php
function rotateArrayFunctional($arr, $positions = 1) {
    $length = count($arr);
    if ($length === 0) return $arr;
    
    $positions = $positions % $length;
    
    return array_merge(
        array_slice($arr, -$positions),
        array_slice($arr, 0, -$positions)
    );
}

// One-liner version
$rotateRight = fn($arr, $pos = 1) => array_merge(
    array_slice($arr, -($pos % count($arr))), 
    array_slice($arr, 0, -($pos % count($arr)))
);
```

**Solution 5 - Object-Oriented Approach (Reusable Class):**
```php
class ArrayRotator {
    private $array;
    
    public function __construct(array $array) {
        $this->array = $array;
    }
    
    public function rotateRight($positions = 1): array {
        $length = count($this->array);
        if ($length === 0) return $this->array;
        
        $positions = $positions % $length;
        
        return array_merge(
            array_slice($this->array, -$positions),
            array_slice($this->array, 0, -$positions)
        );
    }
    
    public function rotateLeft($positions = 1): array {
        $length = count($this->array);
        if ($length === 0) return $this->array;
        
        $positions = $positions % $length;
        
        return array_merge(
            array_slice($this->array, $positions),
            array_slice($this->array, 0, $positions)
        );
    }
    
    public function getOriginal(): array {
        return $this->array;
    }
}

// Usage
$rotator = new ArrayRotator([1, 2, 3, 4, 5, 6, 7]);
$rightRotated = $rotator->rotateRight(1); // [7, 1, 2, 3, 4, 5, 6]
$leftRotated = $rotator->rotateLeft(1);   // [2, 3, 4, 5, 6, 7, 1]
```

**Real-World Application Examples:**

**Image Carousel Implementation:**
```php
class ImageCarousel {
    private $images;
    private $currentIndex = 0;
    
    public function __construct(array $images) {
        $this->images = $images;
    }
    
    public function getVisibleImages($count = 5): array {
        $totalImages = count($this->images);
        $result = [];
        
        for ($i = 0; $i < min($count, $totalImages); $i++) {
            $index = ($this->currentIndex + $i) % $totalImages;
            $result[] = $this->images[$index];
        }
        
        return $result;
    }
    
    public function rotateNext(): void {
        $this->currentIndex = ($this->currentIndex + 1) % count($this->images);
    }
    
    public function rotatePrevious(): void {
        $this->currentIndex = ($this->currentIndex - 1 + count($this->images)) % count($this->images);
    }
}
```

**Task Queue Rotation:**
```php
class TaskQueue {
    private $tasks;
    
    public function __construct(array $tasks) {
        $this->tasks = $tasks;
    }
    
    public function distributeTasksEvenly($workerCount): array {
        $distribution = array_fill(0, $workerCount, []);
        
        foreach ($this->tasks as $index => $task) {
            $workerIndex = $index % $workerCount;
            $distribution[$workerIndex][] = $task;
        }
        
        return $distribution;
    }
    
    public function rotateForLoadBalancing(): array {
        // Rotate tasks to ensure even distribution
        return $this->rotateArrayRight($this->tasks, 1);
    }
    
    private function rotateArrayRight($arr, $positions) {
        $length = count($arr);
        if ($length === 0) return $arr;
        
        $positions = $positions % $length;
        return array_merge(
            array_slice($arr, -$positions),
            array_slice($arr, 0, -$positions)
        );
    }
}
```

**Performance Comparison and Analysis:**

```php
function benchmarkRotationMethods($array, $iterations = 10000) {
    $methods = [
        'Built-in Functions' => fn($arr) => array_merge(array_slice($arr, -1), array_slice($arr, 0, -1)),
        'Manual Loop' => function($arr) {
            $result = [$arr[count($arr) - 1]];
            for ($i = 0; $i < count($arr) - 1; $i++) {
                $result[] = $arr[$i];
            }
            return $result;
        },
        'Array Functions' => fn($arr) => [array_pop($arr)] + $arr,
    ];
    
    foreach ($methods as $name => $method) {
        $start = microtime(true);
        for ($i = 0; $i < $iterations; $i++) {
            $method($array);
        }
        $end = microtime(true);
        echo "$name: " . round(($end - $start) * 1000, 2) . " ms\n";
    }
}

// Test with sample data
$testArray = [1, 2, 3, 4, 5, 6, 7];
benchmarkRotationMethods($testArray);
```

**Algorithm Complexity:**
- **Time Complexity**: O(n) for all solutions where n is array length
- **Space Complexity**: O(n) for creating new array, O(1) for in-place rotation
- **Optimal Choice**: Built-in functions for readability, manual implementation for performance-critical applications

**Edge Cases Handled:**
- Empty arrays return empty arrays
- Single element arrays remain unchanged
- Rotation positions greater than array length are normalized using modulo
- Negative rotations can be converted to positive rotations in opposite direction

This problem demonstrates fundamental array manipulation techniques essential for many real-world applications like pagination, carousel displays, load balancing, and data processing pipelines in web applications.
